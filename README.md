# Svelidate

> Simple and lightweight form validation for Svelte with no dependencies

## Installation

```ts
// npm
npm install svelidate
// yarn
yarn add svelidate
// pnpm
pnpm add svelidate
```

## Usage

-   Star the [github repo](https://github.com/svelidate/svelidate) ðŸ˜Ž

```ts
<script lang="ts">
	import { svelidate, string as s, general as g } from "svelidate"

	const form = svelidate({
		email: {
			value: "",
			validators: [
				general.required("This field is required."),
				string.email("Please enter a valid email."),
			],
			attributes: { // `name` attribute is auto-set to this object's key (`email` here)
				type: "email",
			},
		},
		password: {
			value: "",
			validators: [
				general.required("This field is required."),
				string.lowerCase("Password needs to have atleast one lower case letter."),
				string.upperCase("Password needs to have atleast one upper case letter."),
				string.number("Password needs to have atleast one number."),
				string.symbol("Password needs to have one symbol."),
				string.length.gt(6)("Password needs to have more than 6 characters."),
			],
			attributes: {
				type: "password",
			},
		},
	})
	$form.$on.submit = () => { /*handle submit...*/	}
</script>
```

```svelte
<form on:submit={$form.$fn.submit}>
	<ul> <!-- displaying email errors -->
		{#each $form.email.errors as error}
			<li>{error}</li>
		{/each}
	</ul>
	<input bind:value={$form.email.value} {...$form.email.attributes} />


	<ul> <!-- displaying password errors -->
		{#each $form.password.errors as error}
			<li>{error}</li>
		{/each}
	</ul>
	<input bind:value={$form.password.value} {...$form.password.attributes} />

	<button disabled={$form.$st.invalid}>Submit</button>
</form>
```

## Configuration

You can modify Svelidate's default or local configuration.

-   To modify the default configuration for all `svelidate` functions change this configuration object: `svelidateConfig`.
-   To modify the configuration of one form instance, the modification you want to apply to the default configuration as a second argument in the `svelidate` function.

```ts
{
	mode, /*
	A string indicating which validation mode to use:
		- "default": The default value, uses html only on the server or if
		javascript is disabled, and javascript only otherwise.
		- "all": Uses both html and javascript validation.
		- "js-only": Only uses javascript to validate the binded value.
		- "html-only": Only uses html to validate the input.
	*/
	pattern: { /*
	An object containing regular expression used by the default validators, these
	can be modified to behave differently (e.g. you don't want to count "_" as
	a symbol).
	*/
		symbol, /*
		Pattern used for string.symbol, searches for the following symbols:
		!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .
		*/
		email /*
		Pattern used for string.email.
		*/
	},
}
```

## Form

The Svelidate form object is created from an object representing your desired form.
It's made of field names containing [objects reprensenting your fields](#fields), and top level objects added by Svelidate, beginning with `$`.

### `$st` (state)

```ts
{
	invalid, /*
	A boolean that will be true if any of the form's fields is invalid.
	*/
	submitted, /*
	A boolean that will be true once `$form.$fn.submit` has been called.
	*/
	initial, /*
	The original form passed to `svelidate` to create the svelidate form.
	*/
}
```

### `$fn` (functions)

```ts
{
	submit, /*
	Handles submit internally and then calls the function stored in `$form.$on.submit`.
	*/
	reset, /*
	Resets all fields to their initial value.
	*/
	untouch, /*
	Reset all fields' `touched` property to false. If you only need to reset one
	you can just do `$form.field.touched = false`.
	*/
	getErrors, /*
	Returns all the current field's errors merged into one array.
	*/
}
```

### `$on` (events)

```ts
{
	submit, /*
	Called after submitting with `$form.$fn.submit`.
	*/
	touch, /*
	Called everytime an input is touched (from false to true).
	*/
}
```

## Fields

Fields are used to describe your inputs and create your svelidate form.
The only required property is `value` which should be binded to an input.
If you want your field to be able to have html validation you will need to set `field.attributes.type` to the corresponding input type.

```ts
{
	value, /*
	Used to bind the input's value/checked/etc.
	*/
	validators, /*
	An array of validators, import them or make your own, see the validator
	section.
	*/
	touched, /*
	Boolean indicating if `value` was modified (submitting the form resets
	it to false), it's initial value can be set to true.
	*/
	attributes, /*
	An object containing all the input's attributes (the name attribute is
	automatically set to the field object's key name).
	The title attribute can be used as an error message for the HTML validation
	of string inputs (text, email, password, search, tel, url).
	*/
	errors, /*
	__Generated by svelidate__
	An error message array corresponding to the	invalid javascript validators.
	*/
	invalid, /*
	__Generated by svelidate__
	A boolean that will be true if `errors.length > 0` and false otherwise.
	*/
}
```

## Validators

A validator is an object using this model: `{ js: value => string | undefined, html?: inputType => { ...validationAttributes } }`.
As you can see, in reality it contains two validators:

-   A javascript validator that takes the binded value and returns an error message or undefined.
-   An optional html validator that takes the input's type and returns an object containing all the attributes necessary for html validation (`min`, `max`, etc).

### Default validators

Default validators are grouped together in objects for each input's value types.

#### `general`

```ts
{
	required, /*
	Valid if the value is truthy or if it's equal to 0, the HTML validator
	will add the `required` attribute.
	*/
	truthy, /*
	Valid when value is truthy (can be used to validate booleans).
	*/
	falsy, /*
	Valid when value is falsy (can be used to validate booleans).
	*/
	eq, /*
	Valid if the value is strictly equal to the given argument.
	*/
	neq, /*
	Valid if the value is strictly different from the given argument.
	*/
}
```

#### `string`

**If the passed value is not a string it will be invalid.**

```ts
{
	email, /*
	Valid if the string matches the email pattern.
	*/
	upperCase, /*
	Valid if the string has atleast an upper case letter.
	*/
	lowerCase, /*
	Valid if the string has atleast a lower case letter.
	*/
	number, /*
	Valid if the string has atleast one number.
	*/
	symbol, /*
	Valid if the string has atleast one symbol ( !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~).
	*/
	regex, /*
	Valid if the string matches the given regex.
	*/
	eq, /*
	Valid if the string is strictly equal to the given string.
	*/
	neq, /*
	Valid if the string is strictly different from the given string.
	*/,
	length: {
		gt, /*
		Valid if the string is longer than the given length.
		*/
		gte, /*
		Valid if the string is longer than or equal to the given length.
		*/
		lt, /*
		Valid if the string is shorter than the given length.
		*/
		lte, /*
		Valid if the string is shorter than or equal to the given length.
		*/
		inside, /*
		Valid if the string's length is inside the given interval.
		*/
		outside, /*
		Valid if the string's length is outside the given interval.
		*/
		neq, /*
		Valid if the string's length is strictly different from the given length.
		*/
		eq, /*
		Valid if the string's length is strictly equal to the given length.
		*/
	},
}
```

<details>
	<summary><code>number</code></summary>
<pre lang="ts">
// value must be a number
const number = {
	gt(number: number), // value is greater than the given number.
	gte(number: number), // value is greater than or equal to the given number.
	lt(number: number), // value is lesser than the given number.
	lte(number: number), // value is lesser than or equal to the given number.
	inside(min: number, max: number), // value is in included in the given interval.
	outside(min: number, max: number), // value is in excluded from the given interval.
	neq(number: number), // value is different from the given number.
	eq(number: number), // value is equal to the given number.
}
</pre>
</details>

<details>
	<summary><code>date</code></summary>
<pre lang="ts">
// value must be a string or a date, if it's a string it will be parsed using the `Date` constructor.
const date = {
	gt(date: Date), // value is after the given date.
	gte(date: Date), // value is after the or is the given date.
	lt(date: Date),  // value is before the given date.
	lte(date: Date), // value is before the or is the given date.
	inside(min: Date, max: Date), // value is between the given date range.
	outside(min: Date, max: Date), // value is outside the given date range.
	neq(date: Date), // value is not the given date.
	eq(date: Date), // value is the given date.
}
</pre>
</details>

### Custom validators

You can also create your own validator, a validator takes the binded input `value` has an argument and returns `undefined` if there are no errors or a `string` containing the error message.
Because the error message may change (for example if using translation keys), svelidate provide helper functions to create a validator factory that can take custom error messages.
These helper functions take, a `callback` that must return `true` if the value is valid or `false` if it's not, and a `string` for the default error message (optional).

```ts
import {
	createValidator,
	createStringValidator, // will return an error if value is not a string.
	createNumberValidator, // will return an error if value is not a number.
	createDateValidator, // will return an error if value is not a date (it will try to parse it as a date first using the `Date` constructor).
} from "svelidate"

//
const isObject = createValidator(
	value => typeof value === "object",
	"This is not an object !"
)

const objectValidator = isObject() // this is what you use in form fields (`isObject()`)
objectValidator({}) // return undefined
objectValidator("string") // returns "This is not an object !"

//
// you can also pass params by wrapping it in another function:
const isNumberEqualTo = (number: number) => {
	return createNumberValidator(value => value === number)
}

const threeValidator = isNumberEqualTo(3)("This is not equal to 3 !")
threeValidator(3) // return undefined
threeValidator(69) // return "This is not equal to 3 !"
```

### Conditional validation

You can make any validator or array of validator only validate if a condition is true/undefined by using the `validateIf(predicate: Validator | ValidatorPredicate, validators: Validator | Validator[] )` function.

```ts
import { validateIf, general } from "svelidate"

const value = undefined

// if the predicate returns true or undefined the general.required() will be run as normal
validateIf(() => true, general.required("error"))(value) // returns "error"

// else it won't return any errors, even if the value is not valid
validateIf(() => false, general.required("error"))(value) // returns undefined

// validateIf can also be used to validate arrays
validateIf(
	() => false,
	[general.required("error1"), general.truthy("error2")]
).map(validator => validator(value)) // returns [undefined, undefined]
```

If you want to make a custom validator conditional you can use `createConditionalValidator(predicate: Validator | ValidatorPredicate, validator: Validator)`. Same usage, except it doesn't take arrays.
